"""
Machine Learning Models for Smart Contract Vulnerability Prediction
Implements ML-based analysis for enhanced security detection
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
import re
import hashlib
from datetime import datetime
import logging
from dataclasses import dataclass
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier, IsolationForest
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import joblib
import asyncio

logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityPattern:
    name: str
    pattern: str
    severity: str
    description: str
    confidence: float

@dataclass
class ContractFeatures:
    """Extracted features from smart contract code"""
    # Code complexity metrics
    lines_of_code: int
    cyclomatic_complexity: int
    function_count: int
    modifier_count: int
    event_count: int
    
    # Security-related features
    external_calls: int
    state_variables: int
    payable_functions: int
    require_statements: int
    assert_statements: int
    
    # Pattern-based features
    reentrancy_patterns: int
    overflow_patterns: int
    access_control_patterns: int
    dos_patterns: int
    
    # Code quality metrics
    comment_ratio: float
    documentation_score: float
    naming_convention_score: float

class MLVulnerabilityDetector:
    """Machine Learning-based vulnerability detection system"""
    
    def __init__(self):
        self.feature_extractor = ContractFeatureExtractor()
        self.vulnerability_classifier = None
        self.anomaly_detector = None
        self.vectorizer = TfidfVectorizer(max_features=1000, stop_words='english')
        self.models_trained = False
        
        # Known vulnerability patterns
        self.vulnerability_patterns = [
            VulnerabilityPattern(
                "reentrancy_attack",
                r"\.call\s*\(\s*[^)]*\)\s*;\s*(?!require|assert)",
                "Critical",
                "Potential reentrancy vulnerability - external call without proper guards",
                0.85
            ),
            VulnerabilityPattern(
                "unchecked_send",
                r"\.send\s*\([^)]*\)\s*;(?!\s*require)",
                "High",
                "Unchecked send operation - return value not validated",
                0.80
            ),
            VulnerabilityPattern(
                "integer_overflow",
                r"(?:uint|int)\d*\s+\w+\s*[+\-*/]=|[+\-*/]\s*(?:uint|int)",
                "Medium",
                "Potential integer overflow/underflow vulnerability",
                0.70
            ),
            VulnerabilityPattern(
                "tx_origin_auth",
                r"tx\.origin\s*==\s*\w+",
                "High",
                "Using tx.origin for authentication is vulnerable to phishing attacks",
                0.90
            ),
            VulnerabilityPattern(
                "unprotected_selfdestruct",
                r"selfdestruct\s*\([^)]*\)",
                "Critical",
                "Unprotected selfdestruct function",
                0.85
            ),
            VulnerabilityPattern(
                "delegatecall_injection",
                r"\.delegatecall\s*\(",
                "High",
                "Delegatecall to user-supplied data can lead to code injection",
                0.80
            ),
            VulnerabilityPattern(
                "weak_randomness",
                r"(?:block\.(?:timestamp|difficulty|number|hash)|now)\s*%",
                "Medium",
                "Weak source of randomness using blockchain data",
                0.75
            ),
            VulnerabilityPattern(
                "front_running",
                r"(?:block\.timestamp|now)\s*[<>=]",
                "Medium",
                "Potential front-running vulnerability with timestamp dependency",
                0.65
            )
        ]

    async def initialize_models(self):
        """Initialize and train ML models with synthetic data"""
        try:
            # For production, you would load real vulnerability datasets
            # Here we create synthetic training data for demonstration
            training_data = self._generate_synthetic_training_data()
            
            if len(training_data) > 0:
                await self._train_models(training_data)
                self.models_trained = True
                logger.info("ML models initialized successfully")
            else:
                logger.warning("No training data available - using pattern-based detection only")
                
        except Exception as e:
            logger.error(f"Failed to initialize ML models: {e}")
            # Fallback to pattern-based detection

    def _generate_synthetic_training_data(self) -> List[Dict]:
        """Generate synthetic training data for ML models"""
        # In production, this would be replaced with real vulnerability datasets
        synthetic_data = []
        
        # Vulnerable contract examples
        vulnerable_contracts = [
            {
                "code": """
                contract Vulnerable {
                    mapping(address => uint) balances;
                    
                    function withdraw(uint amount) public {
                        require(balances[msg.sender] >= amount);
                        msg.sender.call.value(amount)("");
                        balances[msg.sender] -= amount;
                    }
                }
                """,
                "vulnerabilities": ["reentrancy_attack"],
                "severity": "Critical"
            },
            {
                "code": """
                contract BadAuth {
                    address owner;
                    
                    function sensitiveFunction() public {
                        require(tx.origin == owner);
                        // sensitive operations
                    }
                }
                """,
                "vulnerabilities": ["tx_origin_auth"],
                "severity": "High"
            }
        ]
        
        # Safe contract examples
        safe_contracts = [
            {
                "code": """
                contract Safe {
                    mapping(address => uint) balances;
                    bool private locked;
                    
                    modifier nonReentrant() {
                        require(!locked);
                        locked = true;
                        _;
                        locked = false;
                    }
                    
                    function withdraw(uint amount) public nonReentrant {
                        require(balances[msg.sender] >= amount);
                        balances[msg.sender] -= amount;
                        msg.sender.transfer(amount);
                    }
                }
                """,
                "vulnerabilities": [],
                "severity": "Low"
            }
        ]
        
        for contract in vulnerable_contracts + safe_contracts:
            features = self.feature_extractor.extract_features(contract["code"])
            synthetic_data.append({
                "features": features,
                "vulnerabilities": contract["vulnerabilities"],
                "is_vulnerable": len(contract["vulnerabilities"]) > 0,
                "severity": contract["severity"]
            })
        
        return synthetic_data

    async def _train_models(self, training_data: List[Dict]):
        """Train ML models on vulnerability data"""
        try:
            # Prepare feature matrix
            X = []
            y_vulnerable = []
            y_severity = []
            
            for item in training_data:
                features = item["features"]
                feature_vector = [
                    features.lines_of_code,
                    features.cyclomatic_complexity,
                    features.function_count,
                    features.external_calls,
                    features.payable_functions,
                    features.require_statements,
                    features.reentrancy_patterns,
                    features.overflow_patterns,
                    features.access_control_patterns,
                    features.comment_ratio
                ]
                X.append(feature_vector)
                y_vulnerable.append(item["is_vulnerable"])
                
                # Convert severity to numeric
                severity_map = {"Low": 0, "Medium": 1, "High": 2, "Critical": 3}
                y_severity.append(severity_map.get(item["severity"], 0))
            
            X = np.array(X)
            y_vulnerable = np.array(y_vulnerable)
            y_severity = np.array(y_severity)
            
            # Train vulnerability classifier
            if len(X) > 1:
                self.vulnerability_classifier = RandomForestClassifier(
                    n_estimators=100,
                    random_state=42,
                    class_weight='balanced'
                )
                self.vulnerability_classifier.fit(X, y_vulnerable)
                
                # Train anomaly detector
                self.anomaly_detector = IsolationForest(
                    contamination=0.1,
                    random_state=42
                )
                self.anomaly_detector.fit(X)
                
                logger.info("ML models trained successfully")
            else:
                logger.warning("Insufficient training data for ML models")
                
        except Exception as e:
            logger.error(f"Model training failed: {e}")

    async def predict_vulnerabilities(self, contract_code: str) -> Dict:
        """Predict vulnerabilities using ML models and pattern matching"""
        results = {
            "pattern_based": [],
            "ml_based": {},
            "combined_score": 0.0,
            "confidence": 0.0
        }
        
        try:
            # Pattern-based detection (always available)
            pattern_vulnerabilities = self._detect_pattern_vulnerabilities(contract_code)
            results["pattern_based"] = pattern_vulnerabilities
            
            # ML-based prediction (if models are trained)
            if self.models_trained and self.vulnerability_classifier is not None:
                ml_prediction = await self._ml_vulnerability_prediction(contract_code)
                results["ml_based"] = ml_prediction
                
                # Combine scores
                pattern_score = len(pattern_vulnerabilities) / 10.0  # Normalize
                ml_score = ml_prediction.get("vulnerability_probability", 0.0)
                results["combined_score"] = (pattern_score + ml_score) / 2.0
                results["confidence"] = min(0.95, 0.5 + (pattern_score * 0.3) + (ml_score * 0.2))
            else:
                results["combined_score"] = len(pattern_vulnerabilities) / 10.0
                results["confidence"] = 0.7  # Pattern-based confidence
            
        except Exception as e:
            logger.error(f"Vulnerability prediction failed: {e}")
            results["error"] = str(e)
        
        return results

    def _detect_pattern_vulnerabilities(self, contract_code: str) -> List[Dict]:
        """Detect vulnerabilities using predefined patterns"""
        vulnerabilities = []
        lines = contract_code.split('\n')
        
        for pattern in self.vulnerability_patterns:
            matches = re.finditer(pattern.pattern, contract_code, re.MULTILINE | re.IGNORECASE)
            for match in matches:
                # Find line number
                line_num = contract_code[:match.start()].count('\n') + 1
                
                vulnerability = {
                    "type": pattern.name,
                    "severity": pattern.severity,
                    "description": pattern.description,
                    "line_number": line_num,
                    "confidence": pattern.confidence,
                    "pattern": pattern.pattern,
                    "match": match.group()
                }
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities

    async def _ml_vulnerability_prediction(self, contract_code: str) -> Dict:
        """Use ML models to predict vulnerabilities"""
        try:
            # Extract features
            features = self.feature_extractor.extract_features(contract_code)
            feature_vector = np.array([[
                features.lines_of_code,
                features.cyclomatic_complexity,
                features.function_count,
                features.external_calls,
                features.payable_functions,
                features.require_statements,
                features.reentrancy_patterns,
                features.overflow_patterns,
                features.access_control_patterns,
                features.comment_ratio
            ]])
            
            predictions = {}
            
            # Vulnerability classification
            if self.vulnerability_classifier:
                vuln_prob = self.vulnerability_classifier.predict_proba(feature_vector)[0]
                predictions["vulnerability_probability"] = float(vuln_prob[1])  # Probability of being vulnerable
                predictions["is_vulnerable"] = bool(self.vulnerability_classifier.predict(feature_vector)[0])
            
            # Anomaly detection
            if self.anomaly_detector:
                anomaly_score = self.anomaly_detector.decision_function(feature_vector)[0]
                predictions["anomaly_score"] = float(anomaly_score)
                predictions["is_anomalous"] = anomaly_score < 0
            
            return predictions
            
        except Exception as e:
            logger.error(f"ML prediction failed: {e}")
            return {"error": str(e)}

class ContractFeatureExtractor:
    """Extract numerical features from smart contract code for ML analysis"""
    
    def extract_features(self, contract_code: str) -> ContractFeatures:
        """Extract comprehensive features from contract code"""
        lines = contract_code.split('\n')
        
        # Basic metrics
        lines_of_code = len([line for line in lines if line.strip() and not line.strip().startswith('//')])
        
        # Count various elements
        function_count = len(re.findall(r'function\s+\w+', contract_code))
        modifier_count = len(re.findall(r'modifier\s+\w+', contract_code))
        event_count = len(re.findall(r'event\s+\w+', contract_code))
        
        # Security-related counts
        external_calls = len(re.findall(r'\.call\s*\(|\.send\s*\(|\.transfer\s*\(', contract_code))
        state_variables = len(re.findall(r'(uint|int|bool|address|string|bytes)\s+(?:public|private|internal)?\s*\w+\s*;', contract_code))
        payable_functions = len(re.findall(r'function\s+\w+[^{]*payable', contract_code))
        require_statements = len(re.findall(r'require\s*\(', contract_code))
        assert_statements = len(re.findall(r'assert\s*\(', contract_code))
        
        # Pattern-based features
        reentrancy_patterns = len(re.findall(r'\.call\s*\(.*\)\s*;(?!\s*require)', contract_code))
        overflow_patterns = len(re.findall(r'[+\-*/]\s*=|[+\-*/]\s*\w+(?!\s*[<>=])', contract_code))
        access_control_patterns = len(re.findall(r'onlyOwner|require\s*\(\s*msg\.sender', contract_code))
        dos_patterns = len(re.findall(r'for\s*\([^{]*\.length|while\s*\([^{]*\.length', contract_code))
        
        # Code quality metrics
        comment_lines = len(re.findall(r'//.*|/\*.*?\*/', contract_code, re.DOTALL))
        comment_ratio = comment_lines / max(lines_of_code, 1)
        
        # Documentation score (simplified)
        natspec_comments = len(re.findall(r'///.*|/\*\*.*?\*/', contract_code, re.DOTALL))
        documentation_score = min(1.0, natspec_comments / max(function_count, 1))
        
        # Naming convention score (simplified)
        camelCase_functions = len(re.findall(r'function\s+[a-z][a-zA-Z0-9]*', contract_code))
        naming_convention_score = camelCase_functions / max(function_count, 1) if function_count > 0 else 1.0
        
        # Cyclomatic complexity (simplified approximation)
        complexity_keywords = len(re.findall(r'\b(if|while|for|case|catch)\b', contract_code))
        cyclomatic_complexity = complexity_keywords + function_count
        
        return ContractFeatures(
            lines_of_code=lines_of_code,
            cyclomatic_complexity=cyclomatic_complexity,
            function_count=function_count,
            modifier_count=modifier_count,
            event_count=event_count,
            external_calls=external_calls,
            state_variables=state_variables,
            payable_functions=payable_functions,
            require_statements=require_statements,
            assert_statements=assert_statements,
            reentrancy_patterns=reentrancy_patterns,
            overflow_patterns=overflow_patterns,
            access_control_patterns=access_control_patterns,
            dos_patterns=dos_patterns,
            comment_ratio=comment_ratio,
            documentation_score=documentation_score,
            naming_convention_score=naming_convention_score
        )

# Global ML detector instance
ml_detector = MLVulnerabilityDetector()

async def initialize_ml_models():
    """Initialize ML models for vulnerability detection"""
    await ml_detector.initialize_models()

async def predict_contract_vulnerabilities(contract_code: str) -> Dict:
    """Predict vulnerabilities in smart contract code"""
    return await ml_detector.predict_vulnerabilities(contract_code)
