from pydantic import BaseModel, Field, validator, ConfigDict
from typing import List, Dict, Any, Optional
from enum import Enum
import datetime

class OptimizationGoal(str, Enum):
    GAS_EFFICIENCY = "gas_efficiency"
    SECURITY_HARDENING = "security_hardening"
    READABILITY = "readability"
    MODULARITY = "modularity"
    UPGRADABILITY = "upgradability"
    STORAGE_OPTIMIZATION = "storage_optimization" # Added from DB schema
    TRANSACTION_SPEED = "transaction_speed" # Added from DB schema

class VulnerabilityType(str, Enum):
    REENTRANCY = "reentrancy"
    INTEGER_OVERFLOW = "integer_overflow"
    ACCESS_CONTROL = "access_control"
    UNHANDLED_EXCEPTIONS = "unhandled_exceptions"
    FRONT_RUNNING = "front_running"
    TIMESTAMP_DEPENDENCE = "timestamp_dependence"
    GAS_LIMIT_ISSUES = "gas_limit_issues"
    DENIAL_OF_SERVICE = "denial_of_service"
    LOGIC_ERRORS = "logic_errors"
    SHORT_ADDRESS_ATTACK = "short_address_attack"

class ContractInput(BaseModel):
    contract_name: Optional[str] = Field(default=None, example="MyToken", description="Name of the smart contract")
    # The field 'code' was previously named 'source_code' in some versions of the plan.
    # Standardizing to 'source_code' for clarity with OptimizationRequest.
    source_code: str = Field(..., example="pragma solidity ^0.8.0; contract MyToken { ... }", description="Smart contract source code")
    # source_type: Optional[str] = Field(default="raw_code", example="raw_code", description="Type of source: raw_code, github_url, etherscan_address") # Potentially for future use
    compiler_version: Optional[str] = Field(default="0.8.20", example="0.8.20", description="Solidity compiler version")

class OptimizationRequest(ContractInput): # Inherits source_code from ContractInput
    optimization_goals: List[OptimizationGoal] = Field(..., example=[OptimizationGoal.GAS_EFFICIENCY, OptimizationGoal.SECURITY_HARDENING], description="List of optimization goals")
    preserve_functionality: bool = Field(default=True, description="Whether to preserve original functionality")

class VulnerabilityInfo(BaseModel):
    type: VulnerabilityType
    severity: str = Field(..., example="High", description="Severity level: Low, Medium, High, Critical")
    line_number: Optional[int] = Field(None, description="Line number where vulnerability is found")
    description: str = Field(..., description="Detailed description of the vulnerability")
    recommendation: str = Field(..., description="Recommended fix for the vulnerability")

class GasFunctionAnalysis(BaseModel):
    function_name: str
    original_gas: Optional[int] = None
    optimized_gas: Optional[int] = None
    savings_absolute: Optional[int] = None
    savings_percentage: Optional[float] = None

    # Note: Pydantic v1 validators are tricky for calculating based on other fields.
    # This logic is better handled in the service layer after the model is populated.
    # For Pydantic v2, computed_fields would be a better fit.
    # Leaving this as a placeholder for intent; actual calculation should be in service.

class AnalysisReport(BaseModel):
    vulnerabilities: List[VulnerabilityInfo] = Field(default_factory=list)
    gas_analysis_per_function: List[GasFunctionAnalysis] = Field(default_factory=list)
    overall_code_quality_score: Optional[float] = Field(None, ge=0, le=10, description="Overall code quality score from 0-10")
    overall_security_score: Optional[float] = Field(None, ge=0, le=10, description="Overall security score from 0-10")
    general_suggestions: List[str] = Field(default_factory=list)
    estimated_total_gas_original: Optional[int] = None
    estimated_total_gas_optimized: Optional[int] = None # Relevant if optimization was part of analysis/rewrite
    total_gas_savings_absolute: Optional[int] = None
    total_gas_savings_percentage: Optional[float] = None

class RewriteReport(BaseModel):
    changes_summary: List[str] = Field(default_factory=list, description="Summary of major changes made")
    # Gas efficiency improvements might be detailed in the main AnalysisReport or specifically here.
    # For now, assuming it's part of the main analysis_report if a rewrite also includes analysis.
    security_enhancements_made: List[str] = Field(default_factory=list) # Specific enhancements due to rewrite
    readability_notes: Optional[str] = None
    # Diff could be a separate field or part of a larger response structure if too big for JSON.

class ContractOutput(BaseModel):
    request_id: str # To correlate with DB entries or logs, can be generated by the server
    original_code: str
    rewritten_code: Optional[str] = None
    
    analysis_report: Optional[AnalysisReport] = None # Analysis can be part of output even for rewrite
    rewrite_report: Optional[RewriteReport] = None # Specific to rewrite operations

    compilation_success_original: Optional[bool] = None
    compilation_success_rewritten: Optional[bool] = None
        
    diff_summary: Optional[str] = None # A textual summary of code changes (e.g. unified diff snippet)
    confidence_score: Optional[float] = Field(None, ge=0, le=1, description="Confidence in the rewrite/analysis quality")
    processing_time_seconds: float = Field(..., description="Processing time in seconds")
    message: str # General message about the operation outcome (e.g., "Analysis complete", "Rewrite successful")

# For the /history endpoint
class ContractHistoryResponse(BaseModel):
    id: str # This will be the DB id (e.g. ContractAnalysisDB.id or ContractRewriteDB.id)
    type: str = Field(..., example="analysis", description="Type of operation: 'analysis' or 'rewrite'")
    contract_name: Optional[str]
    timestamp: datetime.datetime # Use datetime for proper sorting and display formatting
    success: bool # Indicates if the operation itself was successful (e.g. Gemini call worked)
    optimization_goals: Optional[List[OptimizationGoal]] = None # Use the enum for consistency
    details: Dict[str, Any] # To store analysis_report or rewrite_summary from DB JSON

    model_config = ConfigDict(from_attributes=True)  # Pydantic V2 syntax

# Remove the old ContractHistory model if it exists
# class ContractHistory(BaseModel):
#     id: str
#     contract_name: str
#     timestamp: str
#     optimization_goals: List[str]
#     success: bool
#     gas_savings: Optional[int] = None
